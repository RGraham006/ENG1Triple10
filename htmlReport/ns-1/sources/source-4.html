


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > GameScreen</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.mygdx.game</a>
</div>

<h1>Coverage Summary for Class: GameScreen (com.mygdx.game)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GameScreen</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/241)
  </span>
</td>
</tr>
  <tr>
    <td class="name">GameScreen$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/255)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.mygdx.game;
&nbsp;
&nbsp;import com.badlogic.gdx.graphics.g2d.Sprite;
&nbsp;import com.badlogic.gdx.maps.MapLayer;
&nbsp;import com.badlogic.gdx.maps.MapLayers;
&nbsp;import com.mygdx.game.Core.*;
&nbsp;import com.mygdx.game.Core.Interactions.Interactable;
&nbsp;import com.mygdx.game.Core.ValueStructures.CustomerControllerParams;
&nbsp;import com.mygdx.game.Core.ValueStructures.EndOfGameValues;
&nbsp;import com.mygdx.game.Items.Item;
&nbsp;import com.mygdx.game.Items.ItemEnum;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import com.badlogic.gdx.Gdx;
&nbsp;import com.badlogic.gdx.Input;
&nbsp;import com.badlogic.gdx.Screen;
&nbsp;import com.badlogic.gdx.audio.Music;
&nbsp;import com.badlogic.gdx.graphics.Color;
&nbsp;import com.badlogic.gdx.graphics.GL20;
&nbsp;import com.badlogic.gdx.graphics.OrthographicCamera;
&nbsp;import com.badlogic.gdx.graphics.Texture;
&nbsp;import com.badlogic.gdx.graphics.g2d.BitmapFont;
&nbsp;import com.badlogic.gdx.graphics.g2d.TextureAtlas;
&nbsp;import com.badlogic.gdx.graphics.g2d.TextureRegion;
&nbsp;import com.badlogic.gdx.maps.MapObject;
&nbsp;import com.badlogic.gdx.maps.objects.RectangleMapObject;
&nbsp;import com.badlogic.gdx.maps.tiled.TiledMap;
&nbsp;import com.badlogic.gdx.maps.tiled.TiledMapRenderer;
&nbsp;import com.badlogic.gdx.maps.tiled.TmxMapLoader;
&nbsp;import com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer;
&nbsp;import com.badlogic.gdx.math.Rectangle;
&nbsp;import com.badlogic.gdx.math.Vector2;
&nbsp;import com.badlogic.gdx.physics.box2d.Body;
&nbsp;import com.badlogic.gdx.physics.box2d.BodyDef;
&nbsp;import com.badlogic.gdx.physics.box2d.Box2DDebugRenderer;
&nbsp;import com.badlogic.gdx.physics.box2d.Contact;
&nbsp;import com.badlogic.gdx.physics.box2d.ContactImpulse;
&nbsp;import com.badlogic.gdx.physics.box2d.ContactListener;
&nbsp;import com.badlogic.gdx.physics.box2d.FixtureDef;
&nbsp;import com.badlogic.gdx.physics.box2d.Manifold;
&nbsp;import com.badlogic.gdx.physics.box2d.PolygonShape;
&nbsp;import com.badlogic.gdx.physics.box2d.World;
&nbsp;import com.badlogic.gdx.scenes.scene2d.Stage;
&nbsp;import com.badlogic.gdx.scenes.scene2d.ui.Label;
&nbsp;import com.mygdx.game.RecipeAndComb.CombinationDict;
&nbsp;import com.mygdx.game.RecipeAndComb.RecipeDict;
&nbsp;import com.mygdx.game.Stations.*;
&nbsp;
&nbsp;/**
&nbsp; * This is the main class of the game which runs all the logic and rendering Here all the outside
&nbsp; * objects are created and drawn as well as interactions registered
&nbsp; *
&nbsp; * @author Robin Graham
&nbsp; * @author Riko Puusepp
&nbsp; * @author Kelvin Chen
&nbsp; * @author Amy Cross
&nbsp; * @author Labib Zabeneh
&nbsp; */
&nbsp;public class GameScreen implements Screen {
&nbsp;
&nbsp;  // game attributes
&nbsp;  private final MyGdxGame game;
&nbsp;
&nbsp;  // camera
&nbsp;  private final OrthographicCamera camera;
&nbsp;  private Pathfinding pathfinding;
<b class="nc">&nbsp;  private final int TILE_WIDTH = 32;</b>
<b class="nc">&nbsp;  private final int TILE_HEIGHT = 32;</b>
&nbsp;
&nbsp;  // box2d
&nbsp;  static World world;
&nbsp;  private final Box2DDebugRenderer b2dr;
&nbsp;
&nbsp;  private CustomerController customerController;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;  // map
&nbsp;  private final TiledMap map;
&nbsp;  private final TiledMapRenderer mapRenderer;
&nbsp;
&nbsp;  // character assets
&nbsp;  private static ArrayList&lt;TextureAtlas&gt; customerAtlasArray;
<b class="nc">&nbsp;  private final Customer[] customers = new Customer[5];</b>
&nbsp;  private int chefControl;
&nbsp;
&nbsp;  MasterChef masterChef;
&nbsp;  Texture dish1, dish2;
&nbsp;  Texture spaceTexture, ctrlTexture, shiftTexture, rTexture, mTexture;
&nbsp;
<b class="nc">&nbsp;  List&lt;GameObject&gt; Stations = new LinkedList();</b>
<b class="nc">&nbsp;  List&lt;GameObject&gt; customerCounters = new LinkedList();</b>
<b class="nc">&nbsp;  List&lt;GameObject&gt; assemblyStations = new LinkedList();</b>
&nbsp;
<b class="nc">&nbsp;  public Texture menu = new Texture(&quot;recipeSheet.png&quot;);</b>
<b class="nc">&nbsp;  private final int x = 3;</b>
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<b class="nc">&nbsp;  public Texture ingredientsSprites = new Texture(&quot;pixel_veggies1.png&quot;);</b>
<b class="nc">&nbsp;  public TextureRegion tomatoUnchopped = new TextureRegion(ingredientsSprites, 224, 32, 32, 32);</b>
<b class="nc">&nbsp;  public TextureRegion tomatoChopped = new TextureRegion(ingredientsSprites, 256, 32, 32, 32);</b>
<b class="nc">&nbsp;  public TextureRegion lettuceUnchopped = new TextureRegion(ingredientsSprites, 256, 0, 32, 32);</b>
<b class="nc">&nbsp;  public TextureRegion lettuceChopped = new TextureRegion(ingredientsSprites, 288, 0, 32, 32);</b>
<b class="nc">&nbsp;  public TextureRegion onionUnchopped = new TextureRegion(ingredientsSprites, 0, 32, 32, 32);</b>
<b class="nc">&nbsp;  public TextureRegion onionChopped = new TextureRegion(ingredientsSprites, 32, 32, 32, 32);</b>
<b class="nc">&nbsp;  public Texture meatUncooked = new Texture(&quot;pattyUncooked.png&quot;);</b>
<b class="nc">&nbsp;  public Texture meatCooked = new Texture(&quot;pattyCooked.png&quot;);</b>
<b class="nc">&nbsp;  public Texture bunUntoasted = new Texture(&quot;bunUntoasted.png&quot;);</b>
<b class="nc">&nbsp;  public Texture bunToasted = new Texture(&quot;bunToasted.png&quot;);</b>
<b class="nc">&nbsp;  public Texture burger = new Texture(&quot;bourger_32x32.png&quot;);</b>
<b class="nc">&nbsp;  public Texture salad = new Texture(&quot;Salad_32x32.png&quot;);</b>
<b class="nc">&nbsp;  public GameObject exitLogo = new GameObject(new BlackTexture(&quot;Exit.png&quot;));</b>
&nbsp;
&nbsp;  // game timer and displayTimer
<b class="nc">&nbsp;  private float seconds = 0f;</b>
<b class="nc">&nbsp;  private int timer = 0;</b>
&nbsp;  private final Label timerLabel;
&nbsp;  private final Label moneyLabel;
&nbsp;  private final BitmapFont timerFont;
&nbsp;
&nbsp;  Music gameMusic;
&nbsp;
<b class="nc">&nbsp;  public showRecipeInstructions recipeScreen = new showRecipeInstructions();</b>
&nbsp;
&nbsp;  /**
&nbsp;   * Constructor class which initialises all the variables needed to draw the sprites and also
&nbsp;   * manage the logic of the render as well as setting the camera and map
&nbsp;   *
&nbsp;   * @param game base Object which is used to draw on
&nbsp;   */
<b class="nc">&nbsp;  public GameScreen(MyGdxGame game) {</b>
<b class="nc">&nbsp;    this.game = game;</b>
<b class="nc">&nbsp;    camera = new OrthographicCamera();</b>
<b class="nc">&nbsp;    recipeScreen.showRecipeInstruction();</b>
&nbsp;
<b class="nc">&nbsp;    int viewportWidth = 32 * TILE_WIDTH;</b>
<b class="nc">&nbsp;    int viewportHeight = 18 * TILE_HEIGHT;</b>
<b class="nc">&nbsp;    camera.setToOrtho(false, viewportWidth, viewportHeight);</b>
<b class="nc">&nbsp;    camera.update();</b>
&nbsp;
<b class="nc">&nbsp;    gameMusic = Gdx.audio.newMusic(Gdx.files.internal(&quot;gameMusic.mp3&quot;));</b>
<b class="nc">&nbsp;    gameMusic.setLooping(true);</b>
&nbsp;
&nbsp;    // tomatoTexture = new Texture(&quot;tomato_2.png&quot;);
&nbsp;
&nbsp;
<b class="nc">&nbsp;    recipeScreen.createInstructionPage(&quot;Empty&quot;);</b>
&nbsp;
<b class="nc">&nbsp;    dish1 = new Texture(&quot;speech_dish1.png&quot;);</b>
<b class="nc">&nbsp;    dish2 = new Texture(&quot;speech_dish2.png&quot;);</b>
<b class="nc">&nbsp;    spaceTexture = new Texture(&quot;space.png&quot;);</b>
<b class="nc">&nbsp;    ctrlTexture = new Texture(&quot;ctrl.png&quot;);</b>
<b class="nc">&nbsp;    shiftTexture = new Texture(&quot;shift.png&quot;);</b>
<b class="nc">&nbsp;    mTexture = new Texture(&quot;m_key.png&quot;);</b>
<b class="nc">&nbsp;    rTexture = new Texture(&quot;r_key.png&quot;);</b>
<b class="nc">&nbsp;    world = new World(new Vector2(0, 0), true);</b>
<b class="nc">&nbsp;    b2dr = new Box2DDebugRenderer();</b>
<b class="nc">&nbsp;    exitLogo.isVisible = false;</b>
<b class="nc">&nbsp;    exitLogo.getBlackTexture().height=30;</b>
<b class="nc">&nbsp;    exitLogo.getBlackTexture().width=30;</b>
<b class="nc">&nbsp;    exitLogo.position = new Vector2(713, 454);</b>
&nbsp;
&nbsp;    // add map
<b class="nc">&nbsp;    map = new TmxMapLoader().load(&quot;PiazzaPanicMap.tmx&quot;);</b>
<b class="nc">&nbsp;    mapRenderer = new OrthogonalTiledMapRenderer(map);</b>
<b class="nc">&nbsp;    mapRenderer.setView(camera);</b>
&nbsp;
<b class="nc">&nbsp;    pathfinding = new Pathfinding(TILE_WIDTH/4,viewportWidth,viewportWidth);</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;    masterChef = new MasterChef(2,world,camera,pathfinding);</b>
<b class="nc">&nbsp;    GameObjectManager.objManager.AppendLooseScript(masterChef);</b>
&nbsp;
<b class="nc">&nbsp;    CustomerControllerParams CCParams = new CustomerControllerParams();</b>
<b class="nc">&nbsp;    CCParams.MaxMoney = 1000;</b>
<b class="nc">&nbsp;    CCParams.Reputation = 3;</b>
<b class="nc">&nbsp;    CCParams.MoneyStart = 20;</b>
<b class="nc">&nbsp;    customerController = new CustomerController(new Vector2(200,100), new Vector2(360,180), pathfinding, (EndOfGameValues vals) -&gt; EndGame(vals),CCParams, new Vector2(190,390),new Vector2(190,290),new Vector2(290,290));</b>
<b class="nc">&nbsp;    customerController.SetWaveAmount(5);//Demonstration on how to do waves, -1 for endless</b>
&nbsp;
<b class="nc">&nbsp;    GameObjectManager.objManager.AppendLooseScript(customerController);</b>
&nbsp;
<b class="nc">&nbsp;    new CombinationDict();</b>
<b class="nc">&nbsp;    CombinationDict.combinations.implementItems();</b>
<b class="nc">&nbsp;    new RecipeDict();</b>
<b class="nc">&nbsp;    RecipeDict.recipes.implementRecipes();</b>
&nbsp;
&nbsp;    // generate customer sprites to be used by customer class
<b class="nc">&nbsp;    customerAtlasArray = new ArrayList&lt;TextureAtlas&gt;();</b>
<b class="nc">&nbsp;    generateCustomerArray();</b>
&nbsp;//
&nbsp;//    for (int i = 0; i &lt; customers.length; i++) {
&nbsp;//
&nbsp;//      GameObject CustomerGameObject = new GameObject(new BlackSprite());
&nbsp;//      customers[i] = new Customer(i + 1);
&nbsp;//      CustomerGameObject.attachScript(customers[i]);
&nbsp;//      CustomerGameObject.image.setSize(18, 40);
&nbsp;//
&nbsp;//    }
&nbsp;
<b class="nc">&nbsp;    createCollisionListener();</b>
<b class="nc">&nbsp;    int[] objectLayers = {3, 4, 6, 9, 11, 13, 16, 18, 20, 22, 24, 25, 26, 27, 28, 29, 30, 31, 32,</b>
&nbsp;        33, 34, 35, 36, 37, 38, 39};
&nbsp;
&nbsp;    //Fixed the hideous mechanism for creating collidable objects
<b class="nc">&nbsp;    for (int n = 0; n &lt; 17; n++) {</b>
<b class="nc">&nbsp;      MapLayer layer = map.getLayers().get(n);</b>
<b class="nc">&nbsp;      String name = layer.getName();</b>
&nbsp;
<b class="nc">&nbsp;      for (MapObject object : layer.getObjects()</b>
<b class="nc">&nbsp;          .getByType(RectangleMapObject.class)) {</b>
&nbsp;
<b class="nc">&nbsp;        Rectangle rect = ((RectangleMapObject) object).getRectangle();</b>
<b class="nc">&nbsp;        buildObject(world, rect.getX(), rect.getY(), rect.getWidth(), rect.getHeight(), &quot;Static&quot;,</b>
&nbsp;            name);
&nbsp;
<b class="nc">&nbsp;        switch (name) {</b>
&nbsp;          case &quot;bin&quot;:
<b class="nc">&nbsp;            CreateBin(rect);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;counter&quot;:
<b class="nc">&nbsp;            CreateAssembly(rect);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;frying&quot;:
<b class="nc">&nbsp;            CreateHobs(rect);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;chopping board&quot;:
<b class="nc">&nbsp;            CreateChopping(rect);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;toaster&quot;:
<b class="nc">&nbsp;            CreateToaster(rect);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;oven&quot;:
<b class="nc">&nbsp;            CreateOven(rect);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;customer counter&quot;:
<b class="nc">&nbsp;            CreateCustomerCounters(rect);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;tomato&quot;:
<b class="nc">&nbsp;            CreateFoodCrates(rect, ItemEnum.Tomato);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;lettuce&quot;:
<b class="nc">&nbsp;            CreateFoodCrates(rect, ItemEnum.Lettuce);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;onion&quot;:
<b class="nc">&nbsp;            CreateFoodCrates(rect, ItemEnum.Onion);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;mince&quot;:
<b class="nc">&nbsp;            CreateFoodCrates(rect, ItemEnum.Mince);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;buns&quot;:
<b class="nc">&nbsp;            CreateFoodCrates(rect, ItemEnum.Buns);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;dough&quot;:
<b class="nc">&nbsp;            CreateFoodCrates(rect, ItemEnum.Dough);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;cheese&quot;:
<b class="nc">&nbsp;            CreateFoodCrates(rect, ItemEnum.Cheese);</b>
<b class="nc">&nbsp;            break;</b>
&nbsp;          case &quot;potato&quot;:
<b class="nc">&nbsp;            CreateFoodCrates(rect, ItemEnum.Potato);</b>
&nbsp;            break;
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    timerLabel = new Label(&quot;TIME: &quot; + timer,</b>
&nbsp;        new Label.LabelStyle(new BitmapFont(), Color.WHITE));
&nbsp;
<b class="nc">&nbsp;    moneyLabel = new Label(&quot;Money: ¥&quot; + timer,</b>
&nbsp;        new Label.LabelStyle(new BitmapFont(), Color.WHITE));
&nbsp;
<b class="nc">&nbsp;    timerFont = new BitmapFont();</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  void CreateBin(Rectangle rect) {
<b class="nc">&nbsp;    GameObject Bin = new GameObject(null);</b>
<b class="nc">&nbsp;    Bin.setPosition(rect.getX(), rect.getY());</b>
<b class="nc">&nbsp;    Bin.setWidthAndHeight(rect.getWidth(), rect.getHeight());</b>
<b class="nc">&nbsp;    TrashCan TC = new TrashCan();</b>
<b class="nc">&nbsp;    Bin.attachScript(TC);</b>
<b class="nc">&nbsp;    Stations.add(Bin);</b>
&nbsp;  }
&nbsp;
&nbsp;  void CreateHobs(Rectangle rect) {
<b class="nc">&nbsp;    GameObject Hob = new GameObject(null);</b>
<b class="nc">&nbsp;    Hob.setPosition(rect.getX(), rect.getY());</b>
<b class="nc">&nbsp;    Hob.setWidthAndHeight(rect.getWidth(), rect.getHeight());</b>
<b class="nc">&nbsp;    HobStation HS = new HobStation();</b>
<b class="nc">&nbsp;    Hob.attachScript(HS);</b>
<b class="nc">&nbsp;    Stations.add(Hob);</b>
&nbsp;  }
&nbsp;
&nbsp;  void CreateToaster(Rectangle rect) {
<b class="nc">&nbsp;    GameObject Toast = new GameObject(null);</b>
<b class="nc">&nbsp;    Toast.setPosition(rect.getX(), rect.getY());</b>
<b class="nc">&nbsp;    Toast.setWidthAndHeight(rect.getWidth(), rect.getHeight());</b>
<b class="nc">&nbsp;    ToasterStation TS = new ToasterStation();</b>
<b class="nc">&nbsp;    Toast.attachScript(TS);</b>
<b class="nc">&nbsp;    Stations.add(Toast);</b>
&nbsp;  }
&nbsp;
&nbsp;  void CreateChopping(Rectangle rect) {
<b class="nc">&nbsp;    GameObject Chop = new GameObject(null);</b>
<b class="nc">&nbsp;    Chop.setPosition(rect.getX(), rect.getY());</b>
<b class="nc">&nbsp;    Chop.setWidthAndHeight(rect.getWidth(), rect.getHeight());</b>
<b class="nc">&nbsp;    ChopStation CS = new ChopStation();</b>
<b class="nc">&nbsp;    Chop.attachScript(CS);</b>
<b class="nc">&nbsp;    Stations.add(Chop);</b>
&nbsp;  }
&nbsp;
&nbsp;  void CreateOven(Rectangle rect) {
<b class="nc">&nbsp;    GameObject Oven = new GameObject(null);</b>
<b class="nc">&nbsp;    Oven.setPosition(rect.getX(), rect.getY());</b>
<b class="nc">&nbsp;    Oven.setWidthAndHeight(rect.getWidth(), rect.getHeight());</b>
<b class="nc">&nbsp;    OvenStation OS = new OvenStation();</b>
<b class="nc">&nbsp;    Oven.attachScript(OS);</b>
<b class="nc">&nbsp;    Stations.add(Oven);</b>
&nbsp;  }
&nbsp;
&nbsp;  void CreateFoodCrates(Rectangle rect, ItemEnum item) {
<b class="nc">&nbsp;    GameObject Crate = new GameObject(null);</b>
<b class="nc">&nbsp;    Crate.setPosition(rect.getX(), rect.getY());</b>
<b class="nc">&nbsp;    Crate.setWidthAndHeight(rect.getWidth(), rect.getHeight());</b>
<b class="nc">&nbsp;    FoodCrate FC = new FoodCrate(item);</b>
<b class="nc">&nbsp;    Crate.attachScript(FC);</b>
<b class="nc">&nbsp;    Stations.add(Crate);</b>
&nbsp;  }
&nbsp;
&nbsp;  void CreateAssembly(Rectangle rect) {
<b class="nc">&nbsp;    GameObject Ass = new GameObject(null);</b>
<b class="nc">&nbsp;    Ass.setPosition(rect.getX(), rect.getY());</b>
<b class="nc">&nbsp;    Ass.setWidthAndHeight(rect.getWidth(), rect.getHeight());</b>
<b class="nc">&nbsp;    AssemblyStation AS = new AssemblyStation();</b>
<b class="nc">&nbsp;    Ass.attachScript(AS);</b>
<b class="nc">&nbsp;    assemblyStations.add(Ass);</b>
<b class="nc">&nbsp;    Stations.add(Ass);</b>
&nbsp;  }
&nbsp;
&nbsp;  void CreateCustomerCounters(Rectangle rect) {
<b class="nc">&nbsp;    GameObject Cust = new GameObject(null);</b>
<b class="nc">&nbsp;    Cust.setPosition(rect.getX(), rect.getY());</b>
<b class="nc">&nbsp;    Cust.setWidthAndHeight(rect.getWidth(), rect.getHeight());</b>
<b class="nc">&nbsp;    CustomerCounters CC = new CustomerCounters((Item a) -&gt; (customerController.tryGiveFood(a)));</b>
<b class="nc">&nbsp;    Cust.attachScript(CC);</b>
<b class="nc">&nbsp;    customerCounters.add(Cust);</b>
<b class="nc">&nbsp;    Stations.add(Cust);</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   * A function which builds the world box in Box2d which is used for all the hitboxes;
&nbsp;   *
&nbsp;   * @param world  the world it&#39;s being built in
&nbsp;   * @param x      the starting x of the world
&nbsp;   * @param y      the starting y of the world
&nbsp;   * @param width  the width of the world
&nbsp;   * @param height the height of the world
&nbsp;   * @param type   the type of the world
&nbsp;   * @param name   the name of the world
&nbsp;   */
&nbsp;  public void buildObject(World world, float x, float y, float width, float height,
&nbsp;      String type, String name) {
<b class="nc">&nbsp;    BodyDef bdef = new BodyDef();</b>
<b class="nc">&nbsp;    bdef.position.set((x + width / 2), (y + height / 2));</b>
<b class="nc">&nbsp;    if (type == &quot;Static&quot;) {</b>
<b class="nc">&nbsp;      bdef.type = BodyDef.BodyType.StaticBody;</b>
<b class="nc">&nbsp;      pathfinding.addStaticObject((int)x,(int)y,(int)width,(int)height);</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;    } else if (type == &quot;Dynamic&quot;) {</b>
<b class="nc">&nbsp;      bdef.type = BodyDef.BodyType.DynamicBody;</b>
&nbsp;    }
<b class="nc">&nbsp;    Body body = world.createBody(bdef);</b>
<b class="nc">&nbsp;    body.getPosition();</b>
<b class="nc">&nbsp;    body.setUserData(name);</b>
<b class="nc">&nbsp;    PolygonShape shape = new PolygonShape();</b>
<b class="nc">&nbsp;    shape.setAsBox((width / 2), (height / 2));</b>
<b class="nc">&nbsp;    FixtureDef fdef = new FixtureDef();</b>
<b class="nc">&nbsp;    fdef.shape = shape;</b>
<b class="nc">&nbsp;    body.createFixture(fdef);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Generates a customer array which can be used to get random customer sprites from the customer
&nbsp;   * class
&nbsp;   */
&nbsp;  public void generateCustomerArray() {
&nbsp;    String filename;
&nbsp;    TextureAtlas customerAtlas;
&nbsp;
&nbsp;    //The file path takes it to data for each animation
&nbsp;    //The TextureAtlas creates a texture atlas where the you pass through the string of the number and it returns the image.
&nbsp;    //Taking all pictures in the diretory of the file
<b class="nc">&nbsp;    for (int i = 1; i &lt; 9; i++) {</b>
<b class="nc">&nbsp;      filename = &quot;Customers/Customer&quot; + i + &quot;/customer&quot; + i + &quot;.txt&quot;;</b>
<b class="nc">&nbsp;      customerAtlas = new TextureAtlas(filename);</b>
<b class="nc">&nbsp;      customerAtlasArray.add(customerAtlas);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  public void EndGame(EndOfGameValues values){
&nbsp;
<b class="nc">&nbsp;  }</b>
&nbsp;
&nbsp;
&nbsp;  /**
&nbsp;   * Returns the customer array that&#39;s been created
&nbsp;   *
&nbsp;   * @return ArrayList&lt;TextureAtlas&gt; customerAtlasArray;
&nbsp;   */
&nbsp;  public static ArrayList&lt;TextureAtlas&gt; getCustomerAtlasArray() {
<b class="nc">&nbsp;    return customerAtlasArray;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Plays the game music
&nbsp;   */
&nbsp;  @Override
&nbsp;  public void show() {
<b class="nc">&nbsp;    gameMusic.play();</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Displays the timer for the player
&nbsp;   */
&nbsp;  public void displayTimer() {
<b class="nc">&nbsp;    seconds += Gdx.graphics.getDeltaTime();</b>
<b class="nc">&nbsp;    if (seconds &gt;= 1f) {</b>
<b class="nc">&nbsp;      timer++;</b>
<b class="nc">&nbsp;      seconds = 0f;</b>
&nbsp;    }
<b class="nc">&nbsp;    CharSequence str = &quot;TIME: &quot; + timer;</b>
<b class="nc">&nbsp;    timerFont.draw(game.batch, str, 380, 35);</b>
<b class="nc">&nbsp;    timerFont.getData().setScale(1.5f, 1.5f);</b>
<b class="nc">&nbsp;    timerLabel.setText(str);</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;    CharSequence str2 = &quot;Money: ¥&quot; + customerController.Money;</b>
<b class="nc">&nbsp;    timerFont.draw(game.batch, str2, 500, 35);</b>
<b class="nc">&nbsp;    timerFont.getData().setScale(1.5f, 1.5f);</b>
&nbsp;
<b class="nc">&nbsp;    if(customerController.Reputation != -1) {</b>
<b class="nc">&nbsp;      CharSequence str3 = &quot;Reputation: &quot; + customerController.Reputation;</b>
<b class="nc">&nbsp;      timerFont.draw(game.batch, str3, 650, 35);</b>
<b class="nc">&nbsp;      timerFont.getData().setScale(1.5f, 1.5f);</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Calls all logic updates and sprite draws as well as checks if game has been completed
&nbsp;   *
&nbsp;   * @param delta The time in seconds since the last render.
&nbsp;   */
&nbsp;  @Override
&nbsp;  public void render(float delta) {
&nbsp;    //create world
<b class="nc">&nbsp;    Gdx.gl.glClearColor(0, 0, 0, 1);</b>
<b class="nc">&nbsp;    Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);</b>
&nbsp;
&nbsp;    //create camera
<b class="nc">&nbsp;    camera.update();</b>
<b class="nc">&nbsp;    mapRenderer.setView(camera);</b>
<b class="nc">&nbsp;    mapRenderer.render();</b>
&nbsp;
&nbsp;//    for (int i = 0; i &lt; customers.length; i++) {
&nbsp;  //    customers[i].updateSpriteFromInput(customers[i].getMove());
&nbsp;   // }
&nbsp;
&nbsp;    //Removed and simplified logic
&nbsp;
<b class="nc">&nbsp;    world.step(1 / 60f, 6, 2);</b>
&nbsp;
<b class="nc">&nbsp;    game.batch.setProjectionMatrix(camera.combined);</b>
&nbsp;
&nbsp;    //Begins drawing the game batch
<b class="nc">&nbsp;    game.batch.begin();</b>
&nbsp;
&nbsp;    // Calls the function to draw all the ingredients
&nbsp;    //drawIngredients();
&nbsp;
&nbsp;    // Calls the function to display timer
<b class="nc">&nbsp;    displayTimer();</b>
&nbsp;
&nbsp;    //Update Scripts
<b class="nc">&nbsp;    GameObjectManager.objManager.doUpdate(Gdx.graphics.getDeltaTime());</b>
&nbsp;    //New rendering system
<b class="nc">&nbsp;    RenderManager.renderer.onRender(game.batch);</b>
&nbsp;
&nbsp;    // Draws the chefs
<b class="nc">&nbsp;    for (int i = 0; i &lt; masterChef.returnChefCount(); i++) {</b>
&nbsp;      //chef[i].sprite.setSize(18,40);
&nbsp;      //chef[i].sprite.draw(game.batch);
<b class="nc">&nbsp;      if (masterChef.getChef(i).isFrozen) {  // if frozen, need to update timer and sprite</b>
<b class="nc">&nbsp;        masterChef.getChef(i).drawTimer(game.batch);</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // Draws the customers and their orders
&nbsp;//    for (int i = 0; i &lt; customers.length; i++) {
&nbsp;//      //customers[i].gameObject.getSprite().setSize(18, 40);
&nbsp;//      customers[i].draw(game.batch);
&nbsp;//      GameObject foodIcon = customers[i].foodIcon;
&nbsp;//      if (customers[i].isWaiting()) {
&nbsp;//        Customer customer = customers[i];
&nbsp;//        foodIcon.position = new Vector2(((customer.getX() + customer.gameObject.getSprite().sprite.getWidth() / 2) - 5), ((customer.getY() + customer.gameObject.getSprite().sprite.getHeight()) - 5));
&nbsp;//        foodIcon.isVisible = true;
&nbsp;//        if(foodIcon.isClicked(camera)){
&nbsp;//          System.out.println(customer.getDish());
&nbsp;//        }
&nbsp;//      }
&nbsp;///* needs to be changed
&nbsp;//      if (customers[i].getDish() == customerCounters[i].getDish()) {
&nbsp;//        customers[i].fed();
&nbsp;//        foodIcon.isVisible = false;
&nbsp;//        foodIcon = null;
&nbsp;//      }
&nbsp;     // */
&nbsp;
&nbsp;  //  }
&nbsp;
&nbsp;    // Mutes or plays the music
<b class="nc">&nbsp;    if (Gdx.input.isKeyJustPressed((Input.Keys.M))) {</b>
<b class="nc">&nbsp;      if (gameMusic.isPlaying()) {</b>
<b class="nc">&nbsp;        gameMusic.pause();</b>
&nbsp;      } else {
<b class="nc">&nbsp;        gameMusic.play();</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // Draws the instuctions and menu
<b class="nc">&nbsp;    game.batch.draw(spaceTexture, 160, 400, 130, 80);</b>
<b class="nc">&nbsp;    game.batch.draw(ctrlTexture, 280, 410, 90, 60);</b>
<b class="nc">&nbsp;    game.batch.draw(shiftTexture, 360, 415, 90, 50);</b>
<b class="nc">&nbsp;    game.batch.draw(rTexture, 450, 413, 90, 53);</b>
<b class="nc">&nbsp;    game.batch.draw(mTexture, 534, 413, 90, 53);</b>
<b class="nc">&nbsp;    game.batch.draw(menu, 10, 405, 130, 70);</b>
<b class="nc">&nbsp;    game.batch.end();</b>
&nbsp;
&nbsp;    // Runs the logic for the collisions between counters and chefs
<b class="nc">&nbsp;    gameLogic();</b>
&nbsp;
&nbsp;    // Checks if all the customers have been fed and the game is over
&nbsp;//    int fedCounter = 0;
&nbsp;//    for (int i = 0; i &lt; customers.length; i++) {
&nbsp;//      if (customers[i].getFed()) {
&nbsp;//        fedCounter++;
&nbsp;//      }
&nbsp;//    }
&nbsp;//    if (fedCounter == 5) {
&nbsp;//      game.setScreen(new VictoryScreen(game, this, timer));
&nbsp;//    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Checks each chef, counter, station, and assembly station then draws the ingredient sprites on
&nbsp;   * them
&nbsp;   */
&nbsp;
&nbsp;  /**
&nbsp;   * Gets all the collisions and checks if the input keys are pressed and then performs the actions
&nbsp;   * as specified
&nbsp;   */
&nbsp;  public void gameLogic() {
&nbsp;
&nbsp;    // gets all the collisions and iterates through them
<b class="nc">&nbsp;    int numContacts = world.getContactCount();</b>
<b class="nc">&nbsp;    if (numContacts &gt; 0) {</b>
<b class="nc">&nbsp;      for (Contact contact : world.getContactList()) {</b>
<b class="nc">&nbsp;        Object objectA = contact.getFixtureA().getBody().getUserData();</b>
<b class="nc">&nbsp;        Object objectB = contact.getFixtureB().getBody().getUserData();</b>
&nbsp;
&nbsp;        // Checks if the object being interacted with is a chef
<b class="nc">&nbsp;        if (objectB.toString().contentEquals(&quot;Chef&quot; + chefControl) || objectA.toString()</b>
<b class="nc">&nbsp;            .contentEquals(&quot;Chef&quot; + chefControl)) {</b>
&nbsp;
<b class="nc">&nbsp;          boolean isShift = Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT);</b>
<b class="nc">&nbsp;          boolean isSpace = Gdx.input.isKeyJustPressed(Input.Keys.SPACE);</b>
<b class="nc">&nbsp;          boolean isR = Gdx.input.isKeyPressed(Input.Keys.R);</b>
&nbsp;
&nbsp;        }
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Finds all the collisions and assigns the names Also has a convenience function to disregard the
&nbsp;   * chef collision
&nbsp;   */
&nbsp;  public void createCollisionListener() {
<b class="nc">&nbsp;    world.setContactListener(new ContactListener() {</b>
&nbsp;
&nbsp;      /**
&nbsp;       * gets the collision start and finds the names of the things colliding
&nbsp;       *
&nbsp;       * @param contact The object containing collision information
&nbsp;       */
&nbsp;      @Override
&nbsp;      public void beginContact(Contact contact) {
&nbsp;
<b class="nc">&nbsp;        Object objectA = contact.getFixtureA().getBody().getUserData();</b>
<b class="nc">&nbsp;        Object objectB = contact.getFixtureB().getBody().getUserData();</b>
<b class="nc">&nbsp;        Gdx.app.log(&quot;beginContact&quot;, &quot;between &quot; + objectA + &quot; and &quot; + objectB);</b>
&nbsp;      }
&nbsp;
&nbsp;
&nbsp;      /**
&nbsp;       * outputs when two objects have stopped colliding
&nbsp;       *
&nbsp;       * @param contact The object containing decollision information
&nbsp;       */
&nbsp;      @Override
&nbsp;      public void endContact(Contact contact) {
&nbsp;
<b class="nc">&nbsp;        Object objectA = contact.getFixtureA().getBody().getUserData();</b>
<b class="nc">&nbsp;        Object objectB = contact.getFixtureB().getBody().getUserData();</b>
<b class="nc">&nbsp;        Gdx.app.log(&quot;endContact&quot;, &quot;between &quot; + objectA + &quot; and &quot; + objectB);</b>
&nbsp;      }
&nbsp;
&nbsp;      /**
&nbsp;       * Finds out when the two chefs have collided to ignore this collision
&nbsp;       *
&nbsp;       * @param contact The object containing collision information
&nbsp;       * @param oldManifold Needed by the override
&nbsp;       */
&nbsp;      @Override
&nbsp;      public void preSolve(Contact contact, Manifold oldManifold) {
<b class="nc">&nbsp;        Object objectA = contact.getFixtureA().getBody().getUserData();</b>
<b class="nc">&nbsp;        Object objectB = contact.getFixtureB().getBody().getUserData();</b>
<b class="nc">&nbsp;        if ((objectA.toString().contentEquals(&quot;Chef0&quot;)) &amp;&amp; (objectB.toString()</b>
<b class="nc">&nbsp;            .contentEquals(&quot;Chef1&quot;))) {</b>
<b class="nc">&nbsp;          System.out.println(&quot;CONTACT&quot;);</b>
<b class="nc">&nbsp;          contact.setEnabled(false);</b>
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;      @Override
&nbsp;      public void postSolve(Contact contact, ContactImpulse impulse) {
<b class="nc">&nbsp;      }</b>
&nbsp;
&nbsp;    });
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public void resize(int width, int height) {
<b class="nc">&nbsp;  }</b>
&nbsp;
&nbsp;  @Override
&nbsp;  public void pause() {
<b class="nc">&nbsp;  }</b>
&nbsp;
&nbsp;  @Override
&nbsp;  public void resume() {
<b class="nc">&nbsp;  }</b>
&nbsp;
&nbsp;  @Override
&nbsp;  public void hide() {
<b class="nc">&nbsp;  }</b>
&nbsp;
&nbsp;  /**
&nbsp;   * Disposes of all sprites from memory to keep it optimised
&nbsp;   */
&nbsp;  @Override
&nbsp;  public void dispose() {
<b class="nc">&nbsp;    game.batch.dispose();</b>
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-03-28 22:13</div>
</div>
</body>
</html>
